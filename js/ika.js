// Generated by CoffeeScript 1.6.3
(function() {
  'use strict';
  var ikaMain;

  ikaMain = function() {
    var CameraControll, Ika, IkaAggregate, Water, World, c, camera, cameraCtl, i, ika, render, renderer, scene, water, _i;
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(90, 640.0 / 480.0, Math.pow(0.1, 8), Math.pow(10, 3));
    renderer = new THREE.WebGLRenderer({
      antialias: true
    });
    renderer.setFaceCulling("front_and_back");
    c = document.getElementById('c');
    renderer.setSize(640, 480);
    c.appendChild(renderer.domElement);
    World = (function() {
      function World() {}

      World.setup = function(scene) {
        var vertices;
        this.size = 0.5;
        vertices = [new THREE.Vector3(-this.size, -this.size, -this.size), new THREE.Vector3(this.size, -this.size, -this.size), new THREE.Vector3(this.size, this.size, -this.size), new THREE.Vector3(-this.size, this.size, -this.size), new THREE.Vector3(-this.size, -this.size, this.size), new THREE.Vector3(this.size, -this.size, this.size), new THREE.Vector3(this.size, this.size, this.size), new THREE.Vector3(-this.size, this.size, this.size)];
        this.geometry = new THREE.Geometry();
        this.geometry.vertices.push(vertices[0], vertices[1], vertices[2], vertices[3], vertices[7], vertices[4], vertices[5], vertices[6], vertices[2], vertices[6], vertices[7], vertices[3], vertices[0], vertices[4], vertices[5], vertices[1]);
        this.material = new THREE.LineBasicMaterial({
          color: 0x222233,
          depthTest: false,
          transparent: true,
          blending: THREE.AdditiveBlending
        });
        this.mesh = new THREE.Line(this.geometry, this.material);
        return scene.add(this.mesh);
      };

      return World;

    })();
    Water = (function() {
      var WaterBone;

      WaterBone = (function() {
        WaterBone._id = 0;

        WaterBone.material = new THREE.MeshBasicMaterial({
          color: 0x333399,
          depthTest: false,
          transparent: true,
          blending: THREE.AdditiveBlending,
          side: THREE.DoubleSide
        });

        function WaterBone(scene, p) {
          var s;
          this.id = WaterBone._id++;
          this.speed = new THREE.Vector3(0, 0, 0);
          s = 0.002;
          this.geometry = new THREE.BoxGeometry(s, s, s);
          this.mesh = new THREE.Mesh(this.geometry, WaterBone.material);
          this.mesh.position.set(p.x, p.y, p.z);
          scene.add(this.mesh);
        }

        WaterBone.prototype.position = function() {
          return this.mesh.position;
        };

        return WaterBone;

      })();

      Water.surfaceMaterial = new THREE.MeshBasicMaterial({
        color: 0x141744,
        transparent: true,
        depthTest: false,
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide
      });

      Water.sideMaterial = new THREE.MeshBasicMaterial({
        color: 0x090b2a,
        transparent: true,
        depthTest: false,
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide
      });

      Water.bottomMaterial = new THREE.MeshBasicMaterial({
        color: 0x010111,
        transparent: true,
        depthTest: false,
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide
      });

      function Water(scene) {
        var b1, bone, df, face, fault, geo, i, mesh, n, step, triangle, triangles, v, x, z, _i, _j, _k, _l, _len, _len1, _len2, _m, _n, _o, _p, _q, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6,
          _this = this;
        step = 0.10;
        i = 0;
        this.bones = (function() {
          var _i, _ref, _ref1, _results;
          _results = [];
          for (x = _i = _ref = -World.size, _ref1 = World.size + 0.001; step > 0 ? _i < _ref1 : _i > _ref1; x = _i += step) {
            df = i % 2 === 0 ? 0 : step * 0.5;
            i++;
            _results.push((function() {
              var _j, _ref2, _ref3, _results1;
              _results1 = [];
              for (z = _j = _ref2 = -World.size - df, _ref3 = World.size + 0.001 + df; step > 0 ? _j < _ref3 : _j > _ref3; z = _j += step) {
                z = z < -World.size ? z = -World.size : z > World.size ? z = World.size : z;
                _results1.push(new WaterBone(scene, {
                  x: x,
                  y: 0.0,
                  z: z
                }));
              }
              return _results1;
            })());
          }
          return _results;
        })();
        this.surfaceGeometry = new THREE.Geometry();
        this.bonesFlatten = [];
        _ref = _.chain(this.bones).flatten().sortBy(function(x) {
          return x.id;
        }).value();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          x = _ref[_i];
          this.surfaceGeometry.vertices.push(x.position());
          this.bonesFlatten.push(x);
        }
        for (x = _j = 0, _ref1 = this.bones.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          for (z = _k = 0, _ref2 = this.bones[x].length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; z = 0 <= _ref2 ? ++_k : --_k) {
            triangles = x % 2 === 0 ? [[[x, z], [x, z - 1], [x - 1, z]], [[x, z], [x + 1, z], [x, z - 1]]] : [[[x, z], [x - 1, z], [x, z + 1]], [[x, z], [x, z + 1], [x + 1, z]]];
            for (_l = 0, _len1 = triangles.length; _l < _len1; _l++) {
              triangle = triangles[_l];
              fault = false;
              for (_m = 0, _len2 = triangle.length; _m < _len2; _m++) {
                v = triangle[_m];
                fault = this.bones[v[0]] === void 0 || this.bones[v[0]][v[1]] === void 0;
                if (fault) {
                  break;
                }
              }
              if (fault) {
                continue;
              }
              face = new THREE.Face3(this.bones[triangle[0][0]][triangle[0][1]].id, this.bones[triangle[1][0]][triangle[1][1]].id, this.bones[triangle[2][0]][triangle[2][1]].id);
              this.surfaceGeometry.faces.push(face);
            }
          }
        }
        this.surfaceMesh = new THREE.Mesh(this.surfaceGeometry, Water.surfaceMaterial);
        scene.add(this.surfaceMesh);
        this.bottomGeometry = new THREE.Geometry();
        this.bottomGeometry.vertices.push(new THREE.Vector3(-0.5, -0.5, -0.5), new THREE.Vector3(-0.5, -0.5, 0.5), new THREE.Vector3(0.5, -0.5, -0.5), new THREE.Vector3(0.5, -0.5, 0.5));
        this.bottomGeometry.faces.push(new THREE.Face3(0, 1, 2));
        this.bottomGeometry.faces.push(new THREE.Face3(1, 2, 3));
        this.bottomMesh = new THREE.Mesh(this.bottomGeometry, Water.bottomMaterial);
        scene.add(this.bottomMesh);
        this.sideGeometries = [];
        geo = new THREE.Geometry();
        this.sideGeometries.push(geo);
        bone = _.first(this.bones);
        for (n = _n = 0, _ref3 = bone.length; 0 <= _ref3 ? _n < _ref3 : _n > _ref3; n = 0 <= _ref3 ? ++_n : --_n) {
          b1 = bone[n].position().clone();
          b1.y = -0.5;
          geo.vertices.push(bone[n].position(), b1);
          if (bone[n + 1] !== void 0) {
            geo.faces.push(new THREE.Face3(n * 2, n * 2 + 1, n * 2 + 2));
            geo.faces.push(new THREE.Face3(n * 2 + 1, n * 2 + 2, n * 2 + 3));
          }
        }
        mesh = new THREE.Mesh(geo, Water.sideMaterial);
        scene.add(mesh);
        geo = new THREE.Geometry();
        this.sideGeometries.push(geo);
        bone = _.last(this.bones);
        for (n = _o = 0, _ref4 = bone.length; 0 <= _ref4 ? _o < _ref4 : _o > _ref4; n = 0 <= _ref4 ? ++_o : --_o) {
          b1 = bone[n].position().clone();
          b1.y = -0.5;
          geo.vertices.push(bone[n].position(), b1);
          if (bone[n + 1] !== void 0) {
            geo.faces.push(new THREE.Face3(n * 2, n * 2 + 1, n * 2 + 2));
            geo.faces.push(new THREE.Face3(n * 2 + 1, n * 2 + 2, n * 2 + 3));
          }
        }
        mesh = new THREE.Mesh(geo, Water.sideMaterial);
        scene.add(mesh);
        geo = new THREE.Geometry();
        this.sideGeometries.push(geo);
        for (n = _p = 0, _ref5 = this.bones.length; 0 <= _ref5 ? _p < _ref5 : _p > _ref5; n = 0 <= _ref5 ? ++_p : --_p) {
          bone = this.bones[n];
          b1 = _.first(bone).position().clone();
          b1.y = -0.5;
          geo.vertices.push(_.first(bone).position(), b1);
          if (this.bones[n + 1] !== void 0) {
            geo.faces.push(new THREE.Face3(n * 2, n * 2 + 1, n * 2 + 2));
            geo.faces.push(new THREE.Face3(n * 2 + 1, n * 2 + 2, n * 2 + 3));
          }
        }
        mesh = new THREE.Mesh(geo, Water.sideMaterial);
        scene.add(mesh);
        geo = new THREE.Geometry();
        this.sideGeometries.push(geo);
        for (n = _q = 0, _ref6 = this.bones.length; 0 <= _ref6 ? _q < _ref6 : _q > _ref6; n = 0 <= _ref6 ? ++_q : --_q) {
          bone = this.bones[n];
          b1 = _.last(bone).position().clone();
          b1.y = -0.5;
          geo.vertices.push(_.last(bone).position(), b1);
          if (this.bones[n + 1] !== void 0) {
            geo.faces.push(new THREE.Face3(n * 2, n * 2 + 1, n * 2 + 2));
            geo.faces.push(new THREE.Face3(n * 2 + 1, n * 2 + 2, n * 2 + 3));
          }
        }
        mesh = new THREE.Mesh(geo, Water.sideMaterial);
        scene.add(mesh);
      }

      Water.prototype.update = function() {
        var d, f, geo, line, neighbors, px, pz, self, sub, w, work, x, z, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _results;
        work = (function() {
          var _i, _len, _ref, _results;
          _ref = this.bones;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            line = _ref[_i];
            _results.push((function() {
              var _j, _len1, _results1;
              _results1 = [];
              for (_j = 0, _len1 = line.length; _j < _len1; _j++) {
                w = line[_j];
                _results1.push({
                  x: w.position().x,
                  y: w.position().y,
                  z: w.position().z
                });
              }
              return _results1;
            })());
          }
          return _results;
        }).call(this);
        f = 0.01;
        sub = new THREE.Vector3();
        _ref = this.bones;
        for (x = _i = 0, _len = _ref.length; _i < _len; x = ++_i) {
          d = _ref[x];
          _ref1 = this.bones[x];
          for (z = _j = 0, _len1 = _ref1.length; _j < _len1; z = ++_j) {
            d = _ref1[z];
            self = this.bones[x][z];
            neighbors = [[x, z - 1], [x - 1, z - 1], [x - 1, z], [x, z + 1], [x + 1, z], [x + 1, z - 1]];
            for (_k = 0, _len2 = neighbors.length; _k < _len2; _k++) {
              _ref2 = neighbors[_k], px = _ref2[0], pz = _ref2[1];
              if (work[px] !== void 0 && work[px][pz] !== void 0) {
                d = (work[px][pz].y - self.position().y) * f;
                self.speed.y += d;
              }
            }
            self.speed.y += (x * 0.0 - self.position().y) * f;
            self.speed.multiplyScalar(0.92);
            self.position().add(self.speed);
          }
        }
        this.surfaceGeometry.verticesNeedUpdate = true;
        this.surfaceGeometry.computeFaceNormals();
        _ref3 = this.sideGeometries;
        _results = [];
        for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
          geo = _ref3[_l];
          _results.push(geo.verticesNeedUpdate = true);
        }
        return _results;
      };

      Water.prototype.shockIfBoundsChange = function(p, power, nowInWater) {
        var ab_x, ab_z, ap_x, ap_z, bc_x, bc_z, boneA, boneB, boneC, bp_x, bp_z, c1, c2, c3, ca_x, ca_z, center, cp, cp_x, cp_z, f, face, inWater, v_a, v_b, v_c, v_p, _i, _len, _ref;
        _ref = this.surfaceGeometry.faces;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          face = _ref[_i];
          boneA = this.bonesFlatten[face.a];
          boneB = this.bonesFlatten[face.b];
          boneC = this.bonesFlatten[face.c];
          v_a = boneA.position();
          v_b = boneB.position();
          v_c = boneC.position();
          v_p = p;
          ab_x = v_b.x - v_a.x;
          ab_z = v_b.z - v_a.z;
          bp_x = v_p.x - v_b.x;
          bp_z = v_p.z - v_b.z;
          bc_x = v_c.x - v_b.x;
          bc_z = v_c.z - v_b.z;
          cp_x = v_p.x - v_c.x;
          cp_z = v_p.z - v_c.z;
          ca_x = v_a.x - v_c.x;
          ca_z = v_a.z - v_c.z;
          ap_x = v_p.x - v_a.x;
          ap_z = v_p.z - v_a.z;
          c1 = ab_x * bp_z - ab_z * bp_x;
          c2 = bc_x * cp_z - bc_z * cp_x;
          c3 = ca_x * ap_z - ca_z * ap_x;
          if (!((c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0))) {
            continue;
          }
          face.color = new THREE.Color(0xff0000);
          center = new THREE.Vector3(0, 0, 0);
          center.add(v_a);
          center.add(v_b);
          center.add(v_c);
          center.multiplyScalar(1.0 / 3.0);
          cp = center;
          cp.sub(p);
          inWater = face.normal.dot(cp) > 0;
          if (inWater !== nowInWater) {
            f = 0.8;
            boneA.speed.y += power * f;
            boneB.speed.y += power * f;
            boneC.speed.y += power * f;
          }
          return inWater;
        }
      };

      return Water;

    }).call(this);
    Ika = (function() {
      var BackBone;

      BackBone = (function() {
        function BackBone(index, p) {
          this.index = index;
          this.position = new THREE.Vector3(p.x, p.y, p.z);
          this.upAxis = new THREE.Vector3(0, 1, 0);
          this.sideAxis = new THREE.Vector3(1, 0, 0);
        }

        return BackBone;

      })();

      function Ika(scene) {
        var i, index, m, p, v, x, _i, _j, _k, _l, _len, _ref, _ref1, _ref2;
        this.count = 0;
        m = 12;
        p = {
          x: Math.random() * World.size * 2 - World.size,
          y: -Math.random() * World.size,
          z: Math.random() * World.size * 2 - World.size
        };
        this.backBones = (function() {
          var _i, _results;
          _results = [];
          for (index = _i = 0; 0 <= m ? _i < m : _i > m; index = 0 <= m ? ++_i : --_i) {
            _results.push(new BackBone(index, p));
          }
          return _results;
        })();
        this.inWater = p.y < 0;
        this.vertices = (function() {
          var _i, _ref, _results;
          _results = [];
          for (i = _i = 0, _ref = m * 3; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            _results.push(new THREE.Vector3());
          }
          return _results;
        })();
        this.surfaceGeometry = new THREE.Geometry();
        _ref = this.vertices;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          this.surfaceGeometry.vertices.push(v);
        }
        for (i = _j = 0, _ref1 = (this.surfaceGeometry.vertices.length / 3) - 1; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          x = i * 3;
          this.surfaceGeometry.faces.push(new THREE.Face3(x, x + 1, x + 3), new THREE.Face3(x + 3, x + 1, x + 4), new THREE.Face3(x + 2, x + 1, x + 5), new THREE.Face3(x + 4, x + 1, x + 5));
        }
        this.surfaceMaterial = new THREE.MeshBasicMaterial({
          color: 0x111155,
          transparent: true,
          depthTest: false,
          blending: THREE.AdditiveBlending,
          side: THREE.DoubleSide
        });
        this.surfaceMesh = new THREE.Mesh(this.surfaceGeometry, this.surfaceMaterial);
        scene.add(this.surfaceMesh);
        this.outlineGeometry = new THREE.Geometry();
        for (i = _k = 0; 0 <= m ? _k < m : _k > m; i = 0 <= m ? ++_k : --_k) {
          this.outlineGeometry.vertices.push(this.vertices[i * 3]);
        }
        for (i = _l = _ref2 = m - 1; _ref2 <= 0 ? _l <= 0 : _l >= 0; i = _ref2 <= 0 ? ++_l : --_l) {
          this.outlineGeometry.vertices.push(this.vertices[i * 3 + 2]);
        }
        this.outlineMaterial = new THREE.LineBasicMaterial({
          color: 0x222222,
          depthTest: false,
          transparent: true,
          blending: THREE.AdditiveBlending,
          side: THREE.DoubleSide
        });
        this.outlineMesh = new THREE.Line(this.outlineGeometry, this.outlineMaterial);
        scene.add(this.outlineMesh);
        this.eyeAxis = new THREE.Vector3(0, 0, -1);
        this.headAxis = new THREE.Vector3(0, 1, 0);
        this.handAxis = new THREE.Vector3();
        this.handAxis.crossVectors(this.eyeAxis, this.headAxis);
        this.speed = new THREE.Vector3(0, 0, 0);
      }

      Ika.prototype.id = function(_id) {
        this._id = _id != null ? _id : this._id;
        return this._id;
      };

      Ika.prototype.isSelf = function(that) {
        return this.id() === that.id();
      };

      Ika.prototype.position = function() {
        return this.backBones[0].position;
      };

      Ika.prototype.direction = function() {
        return this.eyeAxis;
      };

      Ika.prototype.update = function() {
        var actualDist, alignment, backBone, center, cohesion, f, handDot, i, idealDist, intention, n, nearestOne, nearestSq, others, p, prevInWater, prop, separation, sq, sub, that, u, uc, v, x, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
        if (this.inWater) {
          intention = new THREE.Vector3(0, 0, 0);
          nearestOne = null;
          nearestSq = Number.MAX_VALUE;
          others = [];
          alignment = new THREE.Vector3(0, 0, 0);
          center = new THREE.Vector3(0, 0, 0);
          _ref = IkaAggregate.all();
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            that = _ref[_i];
            if (!this.isSelf(that)) {
              sub = new THREE.Vector3();
              sub.subVectors(this.position(), that.position());
              sq = sub.lengthSq();
              if (sq < nearestSq) {
                nearestSq = sq;
                nearestOne = that;
              }
              if (that.inWater && sq < 0.03 && this.direction().dot(sub) > 0) {
                others.push(that);
                alignment.add(that.direction());
                center.add(that.position());
              }
            }
          }
          idealDist = 0.02;
          actualDist = Math.sqrt(nearestSq);
          if (actualDist < idealDist * 2) {
            sub = new THREE.Vector3();
            sub.subVectors(nearestOne.position(), this.position());
            f = (actualDist - idealDist) / idealDist * 1.0;
            sub.normalize();
            sub.multiplyScalar(f);
            separation = sub;
            intention.add(sub);
          }
          if (others.length > 0) {
            alignment.normalize();
            alignment.multiplyScalar(0.025);
            intention.add(alignment);
            center.multiplyScalar(1.0 / others.length);
            sub = new THREE.Vector3();
            sub.subVectors(center, this.position());
            sub.normalize();
            sub.multiplyScalar(0.04);
            cohesion = sub;
            intention.add(cohesion);
          }
          f = 0.10;
          intention.x -= Math.sin(this.position().x) * f;
          intention.y -= Math.sin(this.position().y) * f;
          intention.z -= Math.sin(this.position().z) * f;
          uc = this.headAxis.clone();
          uc.multiplyScalar(Math.sin(this.count * 0.1) * 0.1);
          intention.add(uc);
          sub = new THREE.Vector3();
          sub = intention.normalize();
          handDot = this.handAxis.dot(sub);
          sub.normalize();
          sub.multiplyScalar(0.00013);
          this.speed.add(sub);
          this.speed.multiplyScalar(0.9990);
        }
        if (!this.inWater) {
          this.speed.add(new THREE.Vector3(0, -0.00015, 0));
          this.speed.multiplyScalar(0.999);
          handDot = 0;
        }
        this.eyeAxis.copy(this.speed);
        this.eyeAxis.normalize();
        this.headAxis.applyAxisAngle(this.eyeAxis, handDot * 0.1);
        this.handAxis.crossVectors(this.eyeAxis, this.headAxis);
        for (n = _j = _ref1 = this.backBones.length - 1; _ref1 <= 1 ? _j <= 1 : _j >= 1; n = _ref1 <= 1 ? ++_j : --_j) {
          this.backBones[n].position.copy(this.backBones[n - 1].position);
          this.backBones[n].sideAxis.copy(this.backBones[n - 1].sideAxis);
          this.backBones[n].upAxis.copy(this.backBones[n - 1].upAxis);
        }
        this.backBones[0].position.add(this.speed);
        this.backBones[0].sideAxis.copy(this.handAxis);
        this.backBones[0].upAxis.copy(this.headAxis);
        p = this.position();
        _ref2 = ['x', 'y', 'z'];
        for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
          prop = _ref2[_k];
          if (p[prop] < -World.size) {
            this.speed[prop] = Math.abs(this.speed[prop]) * 0.9;
          } else if (p[prop] > World.size) {
            this.speed[prop] = -Math.abs(this.speed[prop]) * 0.9;
          }
        }
        _ref3 = this.backBones;
        for (_l = 0, _len2 = _ref3.length; _l < _len2; _l++) {
          backBone = _ref3[_l];
          i = backBone.index;
          x = i < 4 ? i * 2.0 : i < 8 ? (i - 2) * 0.8 : 0.1;
          p = backBone.position;
          v = backBone.sideAxis.clone();
          v.multiplyScalar(x * 0.0007);
          u = backBone.upAxis.clone();
          u.multiplyScalar(Math.sin(i * 0.5 + this.count * 0.2) * (12 - i) * -0.0003);
          this.vertices[i * 3 + 0].set(p.x + v.x + u.x, p.y + v.y + u.y, p.z + v.z + u.z);
          this.vertices[i * 3 + 1].set(p.x, p.y, p.z);
          this.vertices[i * 3 + 2].set(p.x - v.x + u.x, p.y - v.y + u.y, p.z - v.z + u.z);
        }
        prevInWater = this.inWater;
        this.inWater = water.shockIfBoundsChange(this.position(), this.speed.y, this.inWater);
        if (prevInWater !== this.inWater) {
          this.speed.y *= 0.95;
        }
        this.surfaceGeometry.verticesNeedUpdate = true;
        this.outlineGeometry.verticesNeedUpdate = true;
        return this.count++;
      };

      return Ika;

    })();
    IkaAggregate = (function() {
      function IkaAggregate() {}

      IkaAggregate._ikas = [];

      IkaAggregate._id = 0;

      IkaAggregate.register = function(ika) {
        IkaAggregate._ikas.push(ika);
        return ika.id(IkaAggregate.numberingId());
      };

      IkaAggregate.numberingId = function() {
        return ++IkaAggregate._id;
      };

      IkaAggregate.all = function() {
        return IkaAggregate._ikas;
      };

      return IkaAggregate;

    })();
    CameraControll = (function() {
      function CameraControll(camera) {
        var _this = this;
        this.camera = camera;
        this.count = ~~(65536 * Math.random());
        this.cameraWorks = [];
        this.cameraWorks.push(function() {
          return function() {
            _this.camera.up.set(0, 1, 0);
            _this.camera.position.set(Math.cos(_this.count * 0.0021) * 0.7, -Math.sin(_this.count * 0.0012) * 0.5, Math.sin(_this.count * 0.005) * 0.5);
            return _this.camera.lookAt(new THREE.Vector3(0, 0, 0));
          };
        });
        this.cameraWorks.push(function() {
          var maxDist, target;
          maxDist = 0.2;
          target = _.sample(IkaAggregate.all());
          return function() {
            var len, sub;
            sub = target.position().clone();
            sub.sub(_this.camera.position);
            len = sub.length();
            if (len > maxDist) {
              sub.multiplyScalar(0.01);
              _this.camera.position.add(sub);
            }
            _this.camera.up.set(0, 1, 0);
            return _this.camera.lookAt(target.position());
          };
        });
        this.cameraWorks.push(function() {
          var target;
          target = _.sample(IkaAggregate.all());
          return function() {
            var v;
            _this.camera.up.copy(target.headAxis);
            _this.camera.position.copy(target.position());
            v = target.position().clone();
            v.add(target.eyeAxis);
            return _this.camera.lookAt(v);
          };
        });
        this["switch"](0);
      }

      CameraControll.prototype["switch"] = function(n) {
        if (n !== void 0) {
          return this.cameraWork = this.cameraWorks[n]();
        } else {
          return this.cameraWork = _.sample(this.cameraWorks)();
        }
      };

      CameraControll.prototype.update = function() {
        this.cameraWork.call();
        return this.count++;
      };

      return CameraControll;

    })();
    World.setup(scene);
    water = new Water(scene);
    for (i = _i = 0; _i <= 128; i = ++_i) {
      ika = new Ika(scene);
      IkaAggregate.register(ika);
    }
    cameraCtl = new CameraControll(camera);
    renderer.domElement.addEventListener('click', function() {
      return cameraCtl["switch"]();
    });
    render = function() {
      var _j, _len, _ref;
      _ref = IkaAggregate.all();
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        ika = _ref[_j];
        ika.update();
      }
      water.update();
      cameraCtl.update();
      requestAnimationFrame(render);
      return renderer.render(scene, camera);
    };
    return render();
  };

  window.ikaMain = ikaMain;

}).call(this);

/*
//@ sourceMappingURL=ika.map
*/
